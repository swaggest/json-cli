// Code generated by github.com/swaggest/json-cli, DO NOT EDIT.

// Package info contains JSON mapping structures.
package info

import (
	"encoding/json"
	"errors"
	"regexp"
	"strings"
)

// CDataDevJSONCliTestsSrcTestsAssetsSwaggerSchemaJSONDefinitionsInfo structure is generated from "C:\data\dev\json-cli\tests\src/../../tests/assets/swagger-schema.json#/definitions/info".
//
// General information about the API.
type CDataDevJSONCliTestsSrcTestsAssetsSwaggerSchemaJSONDefinitionsInfo struct {
	Title               string                 `json:"title,omitempty"`          // A unique and precise title of the API.
	Version             string                 `json:"version,omitempty"`        // A semantic version number of the API.
	Description         string                 `json:"description,omitempty"`    // A longer description of the API. Should be different from the title.  GitHub Flavored Markdown is allowed.
	TermsOfService      string                 `json:"termsOfService,omitempty"` // The terms of service for the API.
	Contact             *Contact               `json:"contact,omitempty"`        // Contact information for the owners of the API.
	License             *License               `json:"license,omitempty"`
	MapOfAnythingValues map[string]interface{} `json:"-"`                        // Key must match pattern: ^x-
}

type marshalCDataDevJSONCliTestsSrcTestsAssetsSwaggerSchemaJSONDefinitionsInfo CDataDevJSONCliTestsSrcTestsAssetsSwaggerSchemaJSONDefinitionsInfo

// UnmarshalJSON decodes JSON.
func (i *CDataDevJSONCliTestsSrcTestsAssetsSwaggerSchemaJSONDefinitionsInfo) UnmarshalJSON(data []byte) error {
	ii := marshalCDataDevJSONCliTestsSrcTestsAssetsSwaggerSchemaJSONDefinitionsInfo(*i)

	err := unmarshalUnion(
		[]interface{}{&ii},
		nil,
		[]string{
			"title",
			"version",
			"description",
			"termsOfService",
			"contact",
			"license",
		},
		map[string]interface{}{
			"^x-": &ii.MapOfAnythingValues,
		},
		data,
	)
	if err != nil {
		return err
	}
	*i = CDataDevJSONCliTestsSrcTestsAssetsSwaggerSchemaJSONDefinitionsInfo(ii)
	return err
}

// MarshalJSON encodes JSON.
func (i CDataDevJSONCliTestsSrcTestsAssetsSwaggerSchemaJSONDefinitionsInfo) MarshalJSON() ([]byte, error) {
	return marshalUnion(marshalCDataDevJSONCliTestsSrcTestsAssetsSwaggerSchemaJSONDefinitionsInfo(i), i.MapOfAnythingValues)
}

// Contact structure is generated from "#/definitions/contact".
//
// Contact information for the owners of the API.
type Contact struct {
	Name                string                 `json:"name,omitempty"`  // The identifying name of the contact person/organization.
	URL                 string                 `json:"url,omitempty"`   // The URL pointing to the contact information.
	Email               string                 `json:"email,omitempty"` // The email address of the contact person/organization.
	MapOfAnythingValues map[string]interface{} `json:"-"`               // Key must match pattern: ^x-
}

type marshalContact Contact

// UnmarshalJSON decodes JSON.
func (i *Contact) UnmarshalJSON(data []byte) error {
	ii := marshalContact(*i)

	err := unmarshalUnion(
		[]interface{}{&ii},
		nil,
		[]string{
			"name",
			"url",
			"email",
		},
		map[string]interface{}{
			"^x-": &ii.MapOfAnythingValues,
		},
		data,
	)
	if err != nil {
		return err
	}
	*i = Contact(ii)
	return err
}

// MarshalJSON encodes JSON.
func (i Contact) MarshalJSON() ([]byte, error) {
	return marshalUnion(marshalContact(i), i.MapOfAnythingValues)
}

// License structure is generated from "#/definitions/license".
type License struct {
	Name                string                 `json:"name,omitempty"` // The name of the license type. It's encouraged to use an OSI compatible license.
	URL                 string                 `json:"url,omitempty"`  // The URL pointing to the license.
	MapOfAnythingValues map[string]interface{} `json:"-"`              // Key must match pattern: ^x-
}

type marshalLicense License

// UnmarshalJSON decodes JSON.
func (i *License) UnmarshalJSON(data []byte) error {
	ii := marshalLicense(*i)

	err := unmarshalUnion(
		[]interface{}{&ii},
		nil,
		[]string{
			"name",
			"url",
		},
		map[string]interface{}{
			"^x-": &ii.MapOfAnythingValues,
		},
		data,
	)
	if err != nil {
		return err
	}
	*i = License(ii)
	return err
}

// MarshalJSON encodes JSON.
func (i License) MarshalJSON() ([]byte, error) {
	return marshalUnion(marshalLicense(i), i.MapOfAnythingValues)
}

func marshalUnion(maps ...interface{}) ([]byte, error) {
	result := make([]byte, 1, 100)
	result[0] = '{'
	isObject := true
	for _, m := range maps {
		j, err := json.Marshal(m)
		if err != nil {
			return nil, err
		}
		if string(j) == "{}" {
			continue
		}
		if string(j) == "null" {
			continue
		}
		if j[0] != '{' {
			if len(result) == 1 && (isObject || bytes.Equal(result, j)) {
				result = j
				isObject = false
				continue
			}
			return nil, errors.New("failed to union map: object expected, " + string(j) + " received")
		}

		if !isObject {
			return nil, errors.New("failed to union " + string(result) + " and " + string(j))
		}

		if len(result) > 1 {
			result[len(result)-1] = ','
		}
		result = append(result, j[1:]...)
	}
	// Close empty result.
	if isObject && len(result) == 1 {
		result = append(result, '}')
	}

	return result, nil
}
func unmarshalUnion(
	mustUnmarshal []interface{},
	mayUnmarshal []interface{},
	ignoreKeys []string,
	regexMaps map[string]interface{},
	j []byte,
) error {
	for _, item := range mustUnmarshal {
		// unmarshal to struct
		err := json.Unmarshal(j, item)
		if err != nil {
			return err
		}
	}

	for i, item := range mayUnmarshal {
		// unmarshal to struct
		err := json.Unmarshal(j, item)
		if err != nil {
			mayUnmarshal[i] = nil
		}
	}

	// unmarshal to a generic map
	var m map[string]*json.RawMessage
	err := json.Unmarshal(j, &m)
	if err != nil {
		return err
	}

	// removing ignored keys (defined in struct)
	for _, i := range ignoreKeys {
		delete(m, i)
	}

	// returning early on empty map
	if len(m) == 0 {
		return nil
	}

	// preparing regexp matchers
	var reg = make(map[string]*regexp.Regexp, len(regexMaps))
	for regex := range regexMaps {
		if regex != "" {
			reg[regex], err = regexp.Compile(regex)
			if err != nil {
				return err //todo use errors.Wrap
			}
		}
	}

	subMapsRaw := make(map[string][]byte, len(regexMaps))
	// iterating map and feeding subMaps
	for key, val := range m {
		matched := false
		var ok bool
		keyEscaped := `"` + strings.Replace(key, `"`, `\"`, -1) + `":`

		for regex, exp := range reg {
			if exp.MatchString(key) {
				matched = true
				var subMap []byte
				if subMap, ok = subMapsRaw[regex]; !ok {
					subMap = make([]byte, 1, 100)
					subMap[0] = '{'
				} else {
					subMap = append(subMap[:len(subMap)-1], ',')
				}

				subMap = append(subMap, []byte(keyEscaped)...)
				subMap = append(subMap, []byte(*val)...)
				subMap = append(subMap, '}')

				subMapsRaw[regex] = subMap
			}
		}

		// empty regex for additionalProperties
		if !matched {
			var subMap []byte
			if subMap, ok = subMapsRaw[""]; !ok {
				subMap = make([]byte, 1, 100)
				subMap[0] = '{'
			} else {
				subMap = append(subMap[:len(subMap)-1], ',')
			}
			subMap = append(subMap, []byte(keyEscaped)...)
			subMap = append(subMap, []byte(*val)...)
			subMap = append(subMap, '}')

			subMapsRaw[""] = subMap
		}
	}

	for regex := range regexMaps {
		if subMap, ok := subMapsRaw[regex]; !ok {
			continue
		} else {
			err = json.Unmarshal(subMap, regexMaps[regex])
			if err != nil {
				return err
			}
		}
	}
	return nil
}
